/* code generated by tsc, og file in this folder, rs.ts */
var rsDirY = [-1, 0, 1, 0];
var rsDirX = [0, 1, 0, -1];
var RsPiece = /** @class */ (function () {
    function RsPiece(type, state, edit, pistonDir) {
        if (edit === void 0) { edit = true; }
        if (pistonDir === void 0) { pistonDir = 0; }
        this.type = 0 /* Empty */;
        this.state = false;
        this.lastState = false;
        this.type = type;
        this.state = state;
        this.edit = edit;
        this.pistonDir = pistonDir;
    }
    RsPiece.fromChar = function (char) {
        switch (char) {
            case ' ': return new RsPiece(0 /* Empty */, false, true, -1);
            case '.': return new RsPiece(1 /* Dust */, false);
            case '!': return new RsPiece(2 /* Torch */, true, false);
            case '?': return new RsPiece(2 /* Torch */, false, true);
            case '^': return new RsPiece(3 /* Piston */, false, true, 0);
            case '>': return new RsPiece(3 /* Piston */, false, true, 1);
            case 'v': return new RsPiece(3 /* Piston */, false, true, 2);
            case '<': return new RsPiece(3 /* Piston */, false, true, 3);
            case 'o': return new RsPiece(4 /* Block */, false);
            default: return new RsPiece(-1, false, false, -1);
        }
    };
    RsPiece.prototype.innerString = function (index, x, y) {
        switch (this.type) {
            case 0 /* Empty */:
                if (this.pistonDir === -1)
                    return '<img src="img/empty.png"/>';
                else
                    return '<img src="img/pistonEnd' + this.pistonDir + '.png"/>';
            case 1 /* Dust */: return '<img src="img/dust' + (this.state ? 1 : 0) + '.png"/>';
            case 2 /* Torch */:
                if (this.edit) {
                    return '<input type="checkbox" onchange="updaters[' + index + '].toggleCheckbox(this.checked, ' + x + ', ' + y + ')"' +
                        (this.state ? ' checked' : '') + '><img src="img/' +
                        'lever' + (this.state ? 1 : 0) + '.png"/>';
                }
                else
                    return '<img src="img/torch.png"/>';
            case 3 /* Piston */:
                var state = this.state ? 1 : 0;
                return '<img src="img/piston' + state + (this.pistonDir ? 1 : 0) + '.png"/>';
            case 4 /* Block */: return '<img src="img/block.png"/>';
        }
    };
    return RsPiece;
}());
var Updater = /** @class */ (function () {
    function Updater(fId, value, index) {
        this.game = document.getElementById(fId);
        this.index = index;
        this.strLevel = value;
        var lvlLines = this.strLevel.split('#');
        this.env = new Array(lvlLines.length);
        for (var y = 0; y < lvlLines.length; y++) {
            this.env[y] = new Array(lvlLines[y].length);
            for (var x = 0; x < lvlLines[y].length; x++) {
                this.env[y][x] = RsPiece.fromChar(lvlLines[y].charAt(x));
            }
        }
        this.update();
    }
    Updater.prototype.render = function () {
        var inner = "<code>";
        for (var y = 0; y < this.env.length; y++) {
            for (var x = 0; x < this.env[y].length; x++) {
                inner += this.env[y][x].innerString(this.index, x, y);
            }
            inner += "<br>";
        }
        inner += "</code>";
        this.game.innerHTML = inner;
    };
    Updater.prototype.update = function () {
        for (var y = 0; y < this.env.length; y++) {
            for (var x = 0; x < this.env[y].length; x++) {
                var current = this.env[y][x];
                current.lastState = current.state;
                if (current.type != 2 /* Torch */)
                    current.state = false;
            }
        }
        for (var y = 0; y < this.env.length; y++) {
            for (var x = 0; x < this.env[y].length; x++) {
                var current = this.env[y][x];
                if (current.type == 2 /* Torch */) {
                    if (current.state)
                        this.rsSetNeighboursPower(y, x);
                }
            }
        }
        for (var y = 0; y < this.env.length; y++) {
            for (var x = 0; x < this.env[y].length; x++) {
                var current = this.env[y][x];
                if (current.type == 3 /* Piston */) {
                    if (current.lastState != current.state) {
                        if (current.state)
                            this.rsPush(y, x, current.pistonDir, 1, +1); // push
                        else
                            this.rsPush(y, x, current.pistonDir, 2, -1); // or retract
                    }
                }
            }
        }
        this.render();
        if (this.hasChanged())
            this.update();
    };
    Updater.prototype.hasChanged = function () {
        for (var y = 0; y < this.env.length; y++) {
            for (var x = 0; x < this.env[y].length; x++) {
                var current = this.env[y][x];
                if (current.lastState != current.state)
                    return true;
            }
        }
        return false;
    };
    Updater.prototype.rsSetNeighboursPower = function (y, x) {
        for (var dirIndex = 0; dirIndex < 4; dirIndex++) {
            var maybeX = x + (rsDirX[dirIndex]);
            var maybeY = y + (rsDirY[dirIndex]);
            var withed = void 0;
            try {
                withed = this.env[maybeY][maybeX];
                if (withed == undefined)
                    continue;
            }
            catch (_a) {
                continue;
            }
            if (withed.state)
                continue;
            if (!(withed.type & 1))
                continue; // no empty, no torches, no blocks
            if (withed.type == 3 /* Piston */) {
                if (withed.pistonDir == (dirIndex + 2) || withed.pistonDir == (dirIndex - 2))
                    continue; // don't get power from where you are pushing
            }
            withed.state = true;
            if (withed.type == 1 /* Dust */) { // if dust
                this.rsSetNeighboursPower(maybeY, maybeX);
            }
        }
    };
    Updater.prototype.rsPush = function (startY, startX, pDir, dist, sign) {
        var dirX = rsDirX[pDir];
        var dirY = rsDirY[pDir];
        var blockToMoveX = startX + (dirX * dist);
        var blockToMoveY = startY + (dirY * dist);
        if (dist == 2) {
            try {
                if (this[startY + dirY][startX + dirX].type != 0 /* Empty */)
                    return;
            }
            catch (_a) { }
        }
        var withed;
        try {
            withed = this.env[blockToMoveY][blockToMoveX];
            if (withed == undefined)
                return;
        }
        catch (_b) {
            return;
        }
        if (withed.type != 0) {
            var isActivePiston = withed.type == 3 && withed.state;
            if (sign == 1) {
                this.rsPush(blockToMoveY, blockToMoveX, pDir, isActivePiston ? 2 : 1, sign);
            }
            var blockMovedX = blockToMoveX + (dirX * sign);
            var blockMovedY = blockToMoveY + (dirY * sign);
            this.env[blockMovedY][blockMovedX] = this.env[blockToMoveY][blockToMoveX];
            if (sign == 1)
                this.env[blockToMoveY][blockToMoveX] = new RsPiece(0 /* Empty */, false, true, pDir);
            else {
                this.env[blockToMoveY][blockToMoveX] = new RsPiece(0 /* Empty */, false, true, isActivePiston ? pDir : -1);
                this.rsPush(blockToMoveY, blockToMoveX, pDir, isActivePiston ? 2 : 1, sign);
            }
        }
        else {
            if (dist != 2) {
                var current = this.env[startY + dirY][startX + dirX];
                if (current.type == 0)
                    current.pistonDir = -1;
            }
            else
                withed.pistonDir = pDir;
        }
    };
    Updater.prototype.toggleCheckbox = function (c, x, y) {
        this.env[y][x].state = c;
        this.update();
    };
    return Updater;
}());
