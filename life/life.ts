/* code generated by tsc, og file in the same dir: life.ts */

const inputSize: HTMLInputElement = document.getElementById("inputSize") as HTMLInputElement;
const inputNeighDistance: HTMLInputElement = document.getElementById("inputNeighDistance") as HTMLInputElement;
const inputRenderIn2D: HTMLInputElement = document.getElementById("inputRenderIn2D") as HTMLInputElement;
const inputRule: HTMLInputElement = document.getElementById("inputRule") as HTMLInputElement;
const inputWait: HTMLInputElement = document.getElementById("inputWait") as HTMLInputElement;
const inputAuto: HTMLInputElement = document.getElementById("inputAuto") as HTMLInputElement;
const outputElement: HTMLElement = document.getElementById("outputElement");

class Lifer {

	output: string;

	public flush() : void {
		outputElement.innerHTML = this.output;
	}

	cells: boolean[] = [];
	size: number = 0;
	neighDistance: number = 0;
	renderIn2D: boolean = true;
	grandTour: boolean = true;
	auto: boolean = false;
	values: boolean[] = [];
	//count: number = 0;

	constructor() {}

	getCell(index: number) : boolean {
		return this.cells[this.pos(index)];
	}

	setCell(index: number, value: boolean) : void {
		this.cells[this.pos(index)] = value;
	}

	pos(i: number) : number {
		return i < 0 ? this.size - 1 : i >= this.size ? 0 : i;
	}

	start() : void {

		console.log("Project started!");

		this.size = parseInt(inputSize.value);
		this.neighDistance = parseInt(inputNeighDistance.value);
		this.renderIn2D = inputRenderIn2D.checked;
		this.auto = inputAuto.checked;

		let rule: string = inputRule.value;

		this.output = '';

		this.grandTour = rule == "gt";
		if (!this.grandTour) {
			const ruleLenght: number = this.neighDistance * 4 + 2;
			this.values = new Array<boolean>(ruleLenght);
			for (let i: number = 0; i < ruleLenght; i++) this.values[i] = false;
			if (rule.charAt(0) == '$') {
				let decimal: number = parseInt(rule.substr(1));
				if (!isNaN(decimal)) {
					rule = decimal.toString(2);
					while (rule.length < ruleLenght) {
						rule = '0' + rule;
					}
				} else {
					this.output += "rule error: no numeric value after $";
					return;
				}
			}
			if (rule.length < ruleLenght) {
				this.output += "rule error: not enough digits for the rule";
				return;
			} else if (rule.length > ruleLenght) {
				this.output += "number is to big ($0-$" + (1 << ruleLenght - 1) + " | " + ruleLenght + " binary digits)";
				return;
			}
			this.setFromString(rule);
		}

		if (this.grandTour) {
			//this.count = 1 << (this.values.length);
			this.grandStep(0);
		} else {
			this.fill();
			this.randomize();
			this.render(true);
			if (inputAuto.checked) this.step();
		}

	}

	grandStep(i: number) : void {
		if (i % (1 << 4) == 0) {
			let rule: string = (i >> 4).toString(2);
			const ruleLenght: number = this.neighDistance * 4 + 2;
			if (rule.length > ruleLenght) return;
			while (rule.length < ruleLenght) {
				rule = '0' + rule;
			}
			this.setFromString(rule);
			this.output += "grand tour: now at rule " + rule + "<br>";
			this.fill();
			this.randomize();
			this.render(true);
			if (inputAuto.checked) {
				setTimeout(() => {
					this.grandStep(i + 1);
				}, parseInt(inputWait.value));
			}
		} else {
			this.generateNeighboursCount();
			this.render(false);
			if (inputAuto.checked) {
				this.grandStep(i + 1);
			}
		}

	}

	public step() : void {
		this.generateNeighboursCount();
		this.render(true);
		if (inputAuto.checked) {
			setTimeout(() => {
				this.step();
			}, parseInt(inputWait.value));
		}
	}

	setFromString(rule: string) : void {
		this.values = new Array<boolean>(this.neighDistance * 4 + 2);
		for (let i: number = 0; i < rule.length; i++) {
			let v: number = parseInt(rule.charAt(i));
			if (!isNaN(v)) this.values[i] = !!v;
			else { /* maybe thow an error or smn */ }
		}
	}

	countNeighbours(startIndex: number) : number {
		let c: number = 0;
		for (let i: number = 1; i <= this.neighDistance; i++) {
			c += this.getCell(startIndex + i) ? 1 : 0;
			c += this.getCell(startIndex - i) ? 1 : 0;
		} return c;
	}

	generateNeighboursCount() : void {
		for (let i: number = 0; i < this.cells.length; i++) {
			this.cells[i] = this.values[this.countNeighbours(i) * 2 + (this.getCell(i) ? 0 : 1)];
		}
	}

	fill() : void {
		this.cells = new Array<boolean>(this.size);
		for (let i: number = 0; i < this.size; i++) {
			this.cells[i] = false;
		}
	}

	randomize() : void {
		for (let i: number = 0; i < this.cells.length; i++) {
			this.cells[i] = Math.round(Math.random()) != 0;
		}
	}

	render(shouldFlush: boolean) : void {
		if (!this.renderIn2D) this.output = '';
		for (let i: number = 0; i < this.cells.length; i++) {
			this.output += this.cells[i] ? '&nbsp;' : 'O';
		}
		if (this.renderIn2D) this.output += '<br>';
		if (shouldFlush) this.flush();
	}

}

const lifer: Lifer = new Lifer();